/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/validate.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/validate.js":
/*!*************************!*\
  !*** ./src/validate.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// A Validity State Polyfill\r\n;(function (window, document, undefined) {\r\n\r\n    'use strict';\r\n\r\n    // Make sure that ValidityState is supported in full (all features)\r\n    var supported = function () {\r\n        var input = document.createElement('input');\r\n        return ('validity' in input && 'badInput' in input.validity && 'patternMismatch' in input.validity && 'rangeOverflow' in input.validity && 'rangeUnderflow' in input.validity && 'stepMismatch' in input.validity && 'tooLong' in input.validity && 'tooShort' in input.validity && 'typeMismatch' in input.validity && 'valid' in input.validity && 'valueMissing' in input.validity);\r\n    };\r\n\r\n    /**\r\n     * Generate the field validity object\r\n     * @param  {Node]} field The field to validate\r\n     * @return {Object}      The validity object\r\n     */\r\n    var getValidityState = function (field) {\r\n\r\n        // Variables\r\n        var type = field.getAttribute('type') || input.nodeName.toLowerCase();\r\n        var isNum = type === 'number' || type === 'range';\r\n        var length = field.value.length;\r\n        var valid = true;\r\n\r\n        // If radio group, get selected field\r\n        if (field.type === 'radio' && field.name) {\r\n            var group = document.getElementsByName(field.name);\r\n            if (group.length > 0) {\r\n                for (var i = 0; i < group.length; i++) {\r\n                    if (group[i].form === field.form && field.checked) {\r\n                        field = group[i];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Run validity checks\r\n        var checkValidity = {\r\n            badInput: (isNum && length > 0 && !/[-+]?[0-9]/.test(field.value)), // value of a number field is not a number\r\n            patternMismatch: (field.hasAttribute('pattern') && length > 0 && new RegExp(field.getAttribute('pattern')).test(field.value) === false), // value does not conform to the pattern\r\n            rangeOverflow: (field.hasAttribute('max') && isNum && field.value > 0 && Number(field.value) > Number(field.getAttribute('max'))), // value of a number field is higher than the max attribute\r\n            rangeUnderflow: (field.hasAttribute('min') && isNum && field.value > 0 && Number(field.value) < Number(field.getAttribute('min'))), // value of a number field is lower than the min attribute\r\n            stepMismatch: (isNum && ((field.hasAttribute('step') && field.getAttribute('step') !== 'any' && Number(field.value) % Number(field.getAttribute('step')) !== 0) || (!field.hasAttribute('step') && Number(field.value) % 1 !== 0))), // value of a number field does not conform to the stepattribute\r\n            tooLong: (field.hasAttribute('maxLength') && field.getAttribute('maxLength') > 0 && length > parseInt(field.getAttribute('maxLength'), 10)), // the user has edited a too-long value in a field with maxlength\r\n            tooShort: (field.hasAttribute('minLength') && field.getAttribute('minLength') > 0 && length > 0 && length < parseInt(field.getAttribute('minLength'), 10)), // the user has edited a too-short value in a field with minlength\r\n            typeMismatch: (length > 0 && ((type === 'email' && !/^([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22))*\\x40([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d))*$/.test(field.value)) || (type === 'url' && !/^(?:(?:https?|HTTPS?|ftp|FTP):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*)(?::\\d{2,5})?(?:[\\/?#]\\S*)?$/.test(field.value)))), // value of a email or URL field is not an email address or URL\r\n            valueMissing: (field.hasAttribute('required') && (((type === 'checkbox' || type === 'radio') && !field.checked) || (type === 'select' && field.options[field.selectedIndex].value < 1) || (type !=='checkbox' && type !== 'radio' && type !=='select' && length < 1))) // required field without a value\r\n        };\r\n\r\n        // Check if any errors\r\n        for (var key in checkValidity) {\r\n            if (checkValidity.hasOwnProperty(key)) {\r\n                // If there's an error, change valid value\r\n                if (checkValidity[key]) {\r\n                    valid = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add valid property to validity object\r\n        checkValidity.valid = valid;\r\n\r\n        // Return object\r\n        return checkValidity;\r\n\r\n    };\r\n\r\n    // If the full set of ValidityState features aren't supported, polyfill\r\n    // if (!supported()) {\r\n        Object.defineProperty(HTMLInputElement.prototype, 'validity', {\r\n            get: function ValidityState() {\r\n                return getValidityState(this);\r\n            },\r\n            configurable: true,\r\n        });\r\n    // }\r\n\r\n})(window, document);\r\n\r\n\r\n/*\r\n * classList.js: Cross-browser full element.classList implementation.\r\n * 1.1.20170427\r\n *\r\n * By Eli Grey, http://eligrey.com\r\n * License: Dedicated to the public domain.\r\n *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md\r\n */\r\n\r\n/*global self, document, DOMException */\r\n\r\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\r\n\r\nif (\"document\" in self) {\r\n\r\n// Full polyfill for browsers with no classList support\r\n// Including IE < Edge missing SVGElement.classList\r\nif (!(\"classList\" in document.createElement(\"_\")) \r\n    || document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\"))) {\r\n\r\n(function (view) {\r\n\r\n\"use strict\";\r\n\r\nif (!('Element' in view)) return;\r\n\r\nvar\r\n      classListProp = \"classList\"\r\n    , protoProp = \"prototype\"\r\n    , elemCtrProto = view.Element[protoProp]\r\n    , objCtr = Object\r\n    , strTrim = String[protoProp].trim || function () {\r\n        return this.replace(/^\\s+|\\s+$/g, \"\");\r\n    }\r\n    , arrIndexOf = Array[protoProp].indexOf || function (item) {\r\n        var\r\n              i = 0\r\n            , len = this.length\r\n        ;\r\n        for (; i < len; i++) {\r\n            if (i in this && this[i] === item) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    // Vendors: please allow content code to instantiate DOMExceptions\r\n    , DOMEx = function (type, message) {\r\n        this.name = type;\r\n        this.code = DOMException[type];\r\n        this.message = message;\r\n    }\r\n    , checkTokenAndGetIndex = function (classList, token) {\r\n        if (token === \"\") {\r\n            throw new DOMEx(\r\n                  \"SYNTAX_ERR\"\r\n                , \"An invalid or illegal string was specified\"\r\n            );\r\n        }\r\n        if (/\\s/.test(token)) {\r\n            throw new DOMEx(\r\n                  \"INVALID_CHARACTER_ERR\"\r\n                , \"String contains an invalid character\"\r\n            );\r\n        }\r\n        return arrIndexOf.call(classList, token);\r\n    }\r\n    , ClassList = function (elem) {\r\n        var\r\n              trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\")\r\n            , classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\r\n            , i = 0\r\n            , len = classes.length\r\n        ;\r\n        for (; i < len; i++) {\r\n            this.push(classes[i]);\r\n        }\r\n        this._updateClassName = function () {\r\n            elem.setAttribute(\"class\", this.toString());\r\n        };\r\n    }\r\n    , classListProto = ClassList[protoProp] = []\r\n    , classListGetter = function () {\r\n        return new ClassList(this);\r\n    }\r\n;\r\n// Most DOMException implementations don't allow calling DOMException's toString()\r\n// on non-DOMExceptions. Error's toString() is sufficient here.\r\nDOMEx[protoProp] = Error[protoProp];\r\nclassListProto.item = function (i) {\r\n    return this[i] || null;\r\n};\r\nclassListProto.contains = function (token) {\r\n    token += \"\";\r\n    return checkTokenAndGetIndex(this, token) !== -1;\r\n};\r\nclassListProto.add = function () {\r\n    var\r\n          tokens = arguments\r\n        , i = 0\r\n        , l = tokens.length\r\n        , token\r\n        , updated = false\r\n    ;\r\n    do {\r\n        token = tokens[i] + \"\";\r\n        if (checkTokenAndGetIndex(this, token) === -1) {\r\n            this.push(token);\r\n            updated = true;\r\n        }\r\n    }\r\n    while (++i < l);\r\n\r\n    if (updated) {\r\n        this._updateClassName();\r\n    }\r\n};\r\nclassListProto.remove = function () {\r\n    var\r\n          tokens = arguments\r\n        , i = 0\r\n        , l = tokens.length\r\n        , token\r\n        , updated = false\r\n        , index\r\n    ;\r\n    do {\r\n        token = tokens[i] + \"\";\r\n        index = checkTokenAndGetIndex(this, token);\r\n        while (index !== -1) {\r\n            this.splice(index, 1);\r\n            updated = true;\r\n            index = checkTokenAndGetIndex(this, token);\r\n        }\r\n    }\r\n    while (++i < l);\r\n\r\n    if (updated) {\r\n        this._updateClassName();\r\n    }\r\n};\r\nclassListProto.toggle = function (token, force) {\r\n    token += \"\";\r\n\r\n    var\r\n          result = this.contains(token)\r\n        , method = result ?\r\n            force !== true && \"remove\"\r\n        :\r\n            force !== false && \"add\"\r\n    ;\r\n\r\n    if (method) {\r\n        this[method](token);\r\n    }\r\n\r\n    if (force === true || force === false) {\r\n        return force;\r\n    } else {\r\n        return !result;\r\n    }\r\n};\r\nclassListProto.toString = function () {\r\n    return this.join(\" \");\r\n};\r\n\r\nif (objCtr.defineProperty) {\r\n    var classListPropDesc = {\r\n          get: classListGetter\r\n        , enumerable: true\r\n        , configurable: true\r\n    };\r\n    try {\r\n        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\r\n    } catch (ex) { // IE 8 doesn't support enumerable:true\r\n        // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\r\n        // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\r\n        if (ex.number === undefined || ex.number === -0x7FF5EC54) {\r\n            classListPropDesc.enumerable = false;\r\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\r\n        }\r\n    }\r\n} else if (objCtr[protoProp].__defineGetter__) {\r\n    elemCtrProto.__defineGetter__(classListProp, classListGetter);\r\n}\r\n\r\n}(self));\r\n\r\n}\r\n\r\n// There is full or partial native classList support, so just check if we need\r\n// to normalize the add/remove and toggle APIs.\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var testElement = document.createElement(\"_\");\r\n\r\n    testElement.classList.add(\"c1\", \"c2\");\r\n\r\n    // Polyfill for IE 10/11 and Firefox <26, where classList.add and\r\n    // classList.remove exist but support only one argument at a time.\r\n    if (!testElement.classList.contains(\"c2\")) {\r\n        var createMethod = function(method) {\r\n            var original = DOMTokenList.prototype[method];\r\n\r\n            DOMTokenList.prototype[method] = function(token) {\r\n                var i, len = arguments.length;\r\n\r\n                for (i = 0; i < len; i++) {\r\n                    token = arguments[i];\r\n                    original.call(this, token);\r\n                }\r\n            };\r\n        };\r\n        createMethod('add');\r\n        createMethod('remove');\r\n    }\r\n\r\n    testElement.classList.toggle(\"c3\", false);\r\n\r\n    // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\r\n    // support the second argument.\r\n    if (testElement.classList.contains(\"c3\")) {\r\n        var _toggle = DOMTokenList.prototype.toggle;\r\n\r\n        DOMTokenList.prototype.toggle = function(token, force) {\r\n            if (1 in arguments && !this.contains(token) === !force) {\r\n                return force;\r\n            } else {\r\n                return _toggle.call(this, token);\r\n            }\r\n        };\r\n\r\n    }\r\n\r\n    testElement = null;\r\n}());\r\n\r\n}\r\n\r\n\r\n// Add the novalidate attribute when the JS loads\r\nvar forms = document.querySelectorAll('.validate');\r\nfor (var i = 0; i < forms.length; i++) {\r\n    forms[i].setAttribute('novalidate', true);\r\n}\r\n\r\n\r\n// Validate the field\r\nvar hasError = function (field) {\r\n\r\n    // Don't validate submits, buttons, file and reset inputs, and disabled fields\r\n    if (field.disabled || field.type === 'file' || field.type === 'reset' || field.type === 'submit' || field.type === 'button') return;\r\n\r\n    // Get validity\r\n    var validity = field.validity;\r\n\r\n    // If valid, return null\r\n    if (validity.valid) return;\r\n\r\n    // If field is required and empty\r\n    if (validity.valueMissing) return 'Proszę wypełnić to pole.';\r\n\r\n    // If not the right type\r\n    if (validity.typeMismatch) {\r\n\r\n        // Email\r\n        if (field.type === 'email') return 'Proszę podać adres e-mail';\r\n\r\n        // URL\r\n        if (field.type === 'url') return 'Proszę podać adres URL.';\r\n\r\n    }\r\n\r\n    // If too short\r\n    if (validity.tooShort) return 'Please lengthen this text to ' + field.getAttribute('minLength') + ' characters or more. You are currently using ' + field.value.length + ' characters.';\r\n\r\n    // If too long\r\n    if (validity.tooLong) return 'Please shorten this text to no more than ' + field.getAttribute('maxLength') + ' characters. You are currently using ' + field.value.length + ' characters.';\r\n\r\n    // If pattern doesn't match\r\n    if (validity.patternMismatch) {\r\n\r\n        // If pattern info is included, return custom error\r\n        if (field.hasAttribute('title')) return field.getAttribute('title');\r\n\r\n        // Otherwise, generic error\r\n        return 'Please match the requested format.';\r\n\r\n    }\r\n\r\n    // If number input isn't a number\r\n    if (validity.badInput) return 'Please enter a number.';\r\n\r\n    // If a number value doesn't match the step interval\r\n    if (validity.stepMismatch) return 'Please select a valid value.';\r\n\r\n    // If a number field is over the max\r\n    if (validity.rangeOverflow) return 'Please select a value that is no more than ' + field.getAttribute('max') + '.';\r\n\r\n    // If a number field is below the min\r\n    if (validity.rangeUnderflow) return 'Please select a value that is no less than ' + field.getAttribute('min') + '.';\r\n\r\n    // If all else fails, return a generic catchall error\r\n    return 'The value you entered for this field is invalid.';\r\n\r\n};\r\n\r\n\r\n// Show an error message\r\nvar showError = function (field, error) {\r\n\r\n    // Add error class to field\r\n    field.classList.add('error');\r\n  \r\n    // If the field is a radio button and part of a group, error all and get the last item in the group\r\n    if (field.type === 'radio' && field.name) {\r\n        var group = field.form.querySelectorAll('[name=\"' + field.name + '\"]');\r\n        if (group.length > 0) {\r\n            for (var i = 0; i < group.length; i++) {\r\n                group[i].classList.add('error');\r\n            }\r\n            field = group[group.length - 1];\r\n        }\r\n    }\r\n\r\n    // Get field id or name\r\n    var id = field.id || field.name;\r\n    if (!id) return;\r\n\r\n    // Check if error message field already exists\r\n    // If not, create one\r\n    var message = field.form.querySelector('.error-message#error-for-' + id );\r\n    if (!message) {\r\n        message = document.createElement('div');\r\n        message.className = 'error-message';\r\n        message.id = 'error-for-' + id;\r\n        \r\n        // If the field is a radio button or checkbox, insert error after the label\r\n        var label;\r\n        if (field.type === 'radio' || field.type ==='checkbox') {\r\n            label = field.form.querySelector('label[for=\"' + id + '\"]') || field.parentNode;\r\n            if (label) {\r\n                label.parentNode.insertBefore( message, label.nextSibling );\r\n            }\r\n        }\r\n\r\n        // Otherwise, insert it after the field\r\n        if (!label) {\r\n            field.parentNode.insertBefore( message, field.nextSibling );\r\n        }\r\n\r\n    }\r\n    \r\n    // Add ARIA role to the field\r\n    field.setAttribute('aria-describedby', 'error-for-' + id);\r\n\r\n    // Update error message\r\n    message.innerHTML = error;\r\n\r\n    // Show error message\r\n    message.style.display = 'block';\r\n    message.style.visibility = 'visible';\r\n\r\n};\r\n\r\n\r\n// Remove the error message\r\nvar removeError = function (field) {\r\n\r\n    // Remove error class to field\r\n    field.classList.remove('error');\r\n    \r\n    // Remove ARIA role from the field\r\n    field.removeAttribute('aria-describedby');\r\n\r\n    // If the field is a radio button and part of a group, remove error from all and get the last item in the group\r\n    if (field.type === 'radio' && field.name) {\r\n        var group = field.form.querySelectorAll('[name=\"' + field.name + '\"]');\r\n        if (group.length > 0) {\r\n            for (var i = 0; i < group.length; i++) {\r\n                group[i].classList.remove('error');\r\n            }\r\n            field = group[group.length - 1];\r\n        }\r\n    }\r\n\r\n    // Get field id or name\r\n    var id = field.id || field.name;\r\n    if (!id) return;\r\n    \r\n\r\n    // Check if an error message is in the DOM\r\n    var message = field.form.querySelector('.error-message#error-for-' + id + '');\r\n    if (!message) return;\r\n\r\n    // If so, hide it\r\n    message.innerHTML = '';\r\n    message.style.display = 'none';\r\n    message.style.visibility = 'hidden';\r\n\r\n};\r\n\r\n\r\n// Listen to all blur events\r\ndocument.addEventListener('blur', function (event) {\r\n\r\n    // Only run if the field is in a form to be validated\r\n    if (!event.target.form.classList.contains('validate')) return;\r\n\r\n    // Validate the field\r\n    var error = hasError(event.target);\r\n  \r\n    // If there's an error, show it\r\n    if (error) {\r\n        showError(event.target, error);\r\n        return;\r\n    }\r\n\r\n    // Otherwise, remove any existing error message\r\n    removeError(event.target);\r\n\r\n}, true);\r\n\r\n\r\n// Check all fields on submit\r\ndocument.addEventListener('submit', function (event) {\r\n\r\n    // Only run on forms flagged for validation\r\n    if (!event.target.classList.contains('validate')) return;\r\n\r\n    // Get all of the form elements\r\n    var fields = event.target.elements;\r\n\r\n    // Validate each field\r\n    // Store the first field with an error to a variable so we can bring it into focus later\r\n    var error, hasErrors;\r\n    for (var i = 0; i < fields.length; i++) {\r\n        error = hasError(fields[i]);\r\n        if (error) {\r\n            showError(fields[i], error);\r\n            if (!hasErrors) {\r\n                hasErrors = fields[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // If there are errrors, don't submit form and focus on first element with error\r\n    if (hasErrors) {\r\n        event.preventDefault();\r\n        hasErrors.focus();\r\n    }\r\n\r\n    // Otherwise, let the form submit normally\r\n    // You could also bolt in an Ajax form submit process here\r\n\r\n}, false);\n\n//# sourceURL=webpack:///./src/validate.js?");

/***/ })

/******/ });